name: Upstream Release Sync

on:
  schedule:
    - cron: "27 6 * * *" # daily at 06:27 UTC
  workflow_dispatch:
    inputs:
      tag:
        description: "Upstream tag to sync (optional, defaults to latest stable release)"
        required: false
        type: string

permissions: {}

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve upstream release
        id: release
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const manualTag = context.payload?.inputs?.tag?.trim();
            if (manualTag) {
              core.info(`Using workflow-dispatch tag: ${manualTag}`);
              core.setOutput("tag", manualTag);
              return;
            }

            const release = await github.rest.repos.getLatestRelease({
              owner: "openclaw",
              repo: "openclaw",
            });
            if (!release?.data?.tag_name) {
              core.setFailed("No upstream stable release tag found.");
              return;
            }

            core.info(`Latest upstream stable release: ${release.data.tag_name}`);
            core.setOutput("tag", release.data.tag_name);
            core.setOutput("html_url", release.data.html_url || "");

      - name: Configure git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Prepare sync branch
        id: sync
        env:
          TAG: ${{ steps.release.outputs.tag }}
        run: |
          set -euo pipefail

          if [ -z "${TAG}" ]; then
            echo "Missing release tag."
            exit 1
          fi

          SAFE_TAG="${TAG//\//-}"
          BRANCH="sync/upstream-release-${SAFE_TAG}"
          TAG_REF="refs/tags/upstream-sync-${SAFE_TAG}"
          echo "branch=${BRANCH}" >> "$GITHUB_OUTPUT"

          if git remote get-url upstream >/dev/null 2>&1; then
            git remote set-url upstream https://github.com/openclaw/openclaw.git
          else
            git remote add upstream https://github.com/openclaw/openclaw.git
          fi
          git fetch --no-tags origin main
          git fetch --no-tags upstream main
          git fetch upstream "refs/tags/${TAG}:${TAG_REF}"

          if git merge-base --is-ancestor "${TAG_REF}" "origin/main"; then
            echo "Upstream tag ${TAG} is already reachable from origin/main."
            echo "needs_sync=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Capture upstream commit summary before merge attempt
          UPSTREAM_LOG=$(git log --oneline --max-count=30 "origin/main..${TAG_REF}")
          UPSTREAM_COUNT=$(git rev-list --count "origin/main..${TAG_REF}")
          {
            echo "upstream_log<<EOF"
            echo "${UPSTREAM_LOG}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          echo "upstream_count=${UPSTREAM_COUNT}" >> "$GITHUB_OUTPUT"

          filter_workflow_updates() {
            mapfile -t WORKFLOW_FILES < <(git diff --name-only origin/main -- .github/workflows)
            if [ "${#WORKFLOW_FILES[@]}" -eq 0 ]; then
              return 0
            fi

            echo "Detected workflow file changes from upstream; excluding them from automated sync branch."
            git checkout origin/main -- .github/workflows
            git add .github/workflows
            git commit --amend --no-edit

            {
              echo "filtered_workflow_files<<EOF"
              printf '%s\n' "${WORKFLOW_FILES[@]}"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
          }

          if git ls-remote --exit-code --heads origin "${BRANCH}" >/dev/null 2>&1; then
            echo "Remote branch ${BRANCH} already exists; skipping branch overwrite."
            git fetch --no-tags origin "refs/heads/${BRANCH}:refs/remotes/origin/${BRANCH}"

            if git cat-file -e "origin/${BRANCH}:.upstream-sync-pending" 2>/dev/null; then
              echo "Branch still has .upstream-sync-pending marker; keeping conflict PR flow."
              echo "needs_sync=false" >> "$GITHUB_OUTPUT"
              echo "merge_conflict=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            if git merge-base --is-ancestor "${TAG_REF}" "origin/${BRANCH}"; then
              echo "Branch already contains upstream tag ${TAG}; updating/keeping PR only."
              echo "needs_sync=true" >> "$GITHUB_OUTPUT"
              echo "merge_conflict=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            echo "Branch exists but does not contain ${TAG}; leaving branch untouched."
            echo "needs_sync=false" >> "$GITHUB_OUTPUT"
            echo "merge_conflict=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git checkout -B "${BRANCH}" "origin/main"
          if ! git merge --no-ff --no-edit "${TAG_REF}"; then
            mapfile -t CONFLICT_FILES < <(git diff --name-only --diff-filter=U)

            if [ "${#CONFLICT_FILES[@]}" -eq 1 ] && [ "${CONFLICT_FILES[0]}" = "pnpm-lock.yaml" ]; then
              echo "Only pnpm-lock.yaml conflicted; attempting automatic lockfile regeneration."

              if corepack enable && corepack pnpm install --lockfile-only --ignore-scripts; then
                git add pnpm-lock.yaml
                git commit --no-edit
                filter_workflow_updates
                git push -u origin "${BRANCH}"

                echo "needs_sync=true" >> "$GITHUB_OUTPUT"
                echo "merge_conflict=false" >> "$GITHUB_OUTPUT"
                exit 0
              fi

              echo "Automatic pnpm lockfile regeneration failed; falling back to manual conflict flow."
            fi

            git merge --abort || true

            # Create a metadata commit so the branch differs from main
            cat > .upstream-sync-pending <<MARKER
          upstream_tag: ${TAG}
          status: conflict
          created: $(date -u +%Y-%m-%dT%H:%M:%SZ)

          This file was created by the upstream-release-sync workflow.
          The merge of upstream tag ${TAG} into main produced conflicts.
          Resolve them, delete this file, and push to this branch.
          MARKER
            git add .upstream-sync-pending
            git commit -m "chore: mark pending upstream sync for ${TAG} (conflicts)"

            git push -u origin "${BRANCH}"

            echo "needs_sync=false" >> "$GITHUB_OUTPUT"
            echo "merge_conflict=true" >> "$GITHUB_OUTPUT"
            {
              echo "conflict_files<<EOF"
              if [ "${#CONFLICT_FILES[@]}" -gt 0 ]; then
                printf '%s\n' "${CONFLICT_FILES[@]}"
              fi
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          filter_workflow_updates
          git push -u origin "${BRANCH}"

          echo "needs_sync=true" >> "$GITHUB_OUTPUT"
          echo "merge_conflict=false" >> "$GITHUB_OUTPUT"

      - name: Open or update draft PR (conflicts)
        if: steps.sync.outputs.merge_conflict == 'true'
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        env:
          TAG: ${{ steps.release.outputs.tag }}
          TAG_URL: ${{ steps.release.outputs.html_url }}
          BRANCH: ${{ steps.sync.outputs.branch }}
          CONFLICT_FILES: ${{ steps.sync.outputs.conflict_files }}
          UPSTREAM_LOG: ${{ steps.sync.outputs.upstream_log }}
          UPSTREAM_COUNT: ${{ steps.sync.outputs.upstream_count }}
          RUN_ID: ${{ github.run_id }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = `${owner}:${process.env.BRANCH}`;
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${process.env.RUN_ID}`;
            const title = `chore: sync upstream ${process.env.TAG}`;
            const releaseUrl =
              process.env.TAG_URL || `https://github.com/openclaw/openclaw/releases/tag/${process.env.TAG}`;
            const conflictFiles = (process.env.CONFLICT_FILES || "")
              .split("\n")
              .map((item) => item.trim())
              .filter(Boolean);
            const filesBody =
              conflictFiles.length > 0
                ? conflictFiles.map((file) => `- \`${file}\``).join("\n")
                : "- (Unable to detect conflicted files from merge output)";
            const upstreamLog = process.env.UPSTREAM_LOG || "(unable to retrieve)";
            const upstreamCount = process.env.UPSTREAM_COUNT || "?";

            const body = [
              `> **Status: merge conflicts — manual resolution required**`,
              "",
              `Automated sync from upstream stable release \`${process.env.TAG}\` hit merge conflicts.`,
              "",
              `| | |`,
              `|---|---|`,
              `| **Upstream release** | ${releaseUrl} |`,
              `| **Sync branch** | \`${process.env.BRANCH}\` |`,
              `| **Workflow run** | ${runUrl} |`,
              "",
              "## Conflicted files",
              filesBody,
              "",
              `## Upstream changes (${upstreamCount} commits)`,
              "```",
              upstreamLog,
              "```",
              "",
              "## Resolution",
              "```bash",
              `git fetch origin ${process.env.BRANCH} && git fetch upstream --tags`,
              `git checkout -B ${process.env.BRANCH} origin/${process.env.BRANCH}`,
              `git merge --no-ff --no-edit refs/tags/${process.env.TAG}`,
              "# resolve conflicts, then:",
              `git rm .upstream-sync-pending || true`,
              `git commit`,
              `git push origin ${process.env.BRANCH}`,
              "```",
              "Mark this PR as **Ready for review** once conflicts are resolved.",
              "",
              "---",
              "This PR was created by `.github/workflows/upstream-release-sync.yml`.",
            ].join("\n");

            // Ensure upstream-sync label exists
            try {
              await github.rest.issues.getLabel({ owner, repo, name: "upstream-sync" });
            } catch {
              await github.rest.issues.createLabel({
                owner, repo, name: "upstream-sync",
                color: "1d76db", description: "Automated upstream release sync",
              });
            }

            const existing = await github.rest.pulls.list({
              owner, repo, state: "open", base: "main", head, per_page: 1,
            });

            if (existing.data.length > 0) {
              const pull = existing.data[0];
              await github.rest.pulls.update({
                owner, repo, pull_number: pull.number, title, body,
              });
              core.info(`Updated existing draft PR #${pull.number}`);
              return;
            }

            try {
              const created = await github.rest.pulls.create({
                owner, repo, base: "main", head: process.env.BRANCH,
                title, body, draft: true,
              });
              await github.rest.issues.addLabels({
                owner, repo, issue_number: created.data.number,
                labels: ["upstream-sync"],
              });
              core.info(`Created draft PR #${created.data.number}`);
            } catch (error) {
              if (error?.status === 422 && String(error?.message || "").includes("No commits between")) {
                core.warning(`Skipping draft PR creation: no commits between main and ${process.env.BRANCH}.`);
                return;
              }
              throw error;
            }

      - name: Open or update pull request
        if: steps.sync.outputs.needs_sync == 'true'
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        env:
          TAG: ${{ steps.release.outputs.tag }}
          TAG_URL: ${{ steps.release.outputs.html_url }}
          BRANCH: ${{ steps.sync.outputs.branch }}
          UPSTREAM_LOG: ${{ steps.sync.outputs.upstream_log }}
          UPSTREAM_COUNT: ${{ steps.sync.outputs.upstream_count }}
          FILTERED_WORKFLOW_FILES: ${{ steps.sync.outputs.filtered_workflow_files }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = `${owner}:${process.env.BRANCH}`;
            const title = `chore: sync upstream ${process.env.TAG}`;
            const releaseUrl = process.env.TAG_URL || `https://github.com/openclaw/openclaw/releases/tag/${process.env.TAG}`;
            const upstreamLog = process.env.UPSTREAM_LOG || "(unable to retrieve)";
            const upstreamCount = process.env.UPSTREAM_COUNT || "?";
            const filteredWorkflowFiles = (process.env.FILTERED_WORKFLOW_FILES || "")
              .split("\n")
              .map((item) => item.trim())
              .filter(Boolean);
            const filteredWorkflowSection =
              filteredWorkflowFiles.length > 0
                ? [
                    "",
                    "## Workflow files excluded from this automated sync",
                    "These files were reset to `main` to avoid GitHub token restrictions on workflow-file updates:",
                    ...filteredWorkflowFiles.map((file) => `- \`${file}\``),
                  ]
                : [];

            const body = [
              `Automated sync from upstream stable release \`${process.env.TAG}\`.`,
              "",
              `Upstream release: ${releaseUrl}`,
              "",
              `## Upstream changes (${upstreamCount} commits)`,
              "```",
              upstreamLog,
              "```",
              ...filteredWorkflowSection,
              "",
              "---",
              "This PR was created by `.github/workflows/upstream-release-sync.yml`.",
            ].join("\n");

            // Ensure upstream-sync label exists
            try {
              await github.rest.issues.getLabel({ owner, repo, name: "upstream-sync" });
            } catch {
              await github.rest.issues.createLabel({
                owner, repo, name: "upstream-sync",
                color: "1d76db", description: "Automated upstream release sync",
              });
            }

            const existing = await github.rest.pulls.list({
              owner, repo, state: "open", base: "main", head, per_page: 1,
            });

            if (existing.data.length > 0) {
              const pull = existing.data[0];
              await github.rest.pulls.update({
                owner, repo, pull_number: pull.number, title, body,
              });
              if (pull.draft) {
                try {
                  await github.rest.pulls.readyForReview({
                    owner,
                    repo,
                    pull_number: pull.number,
                  });
                  core.info(`Marked PR #${pull.number} ready for review`);
                } catch (error) {
                  if (error?.status !== 422) {
                    throw error;
                  }
                }
              }
              core.info(`Updated existing PR #${pull.number}`);
              return;
            }

            try {
              const created = await github.rest.pulls.create({
                owner, repo, base: "main", head: process.env.BRANCH,
                title, body,
              });
              await github.rest.issues.addLabels({
                owner, repo, issue_number: created.data.number,
                labels: ["upstream-sync"],
              });
              core.info(`Created PR #${created.data.number}`);
            } catch (error) {
              if (error?.status === 422 && String(error?.message || "").includes("No commits between")) {
                core.warning(`Skipping PR creation: no commits between main and ${process.env.BRANCH}.`);
                return;
              }
              throw error;
            }

      - name: Close resolved conflict issues
        if: steps.sync.outputs.needs_sync == 'true'
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        env:
          TAG: ${{ steps.release.outputs.tag }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Close any leftover conflict issues from before the draft-PR migration
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner, repo, state: "open",
              creator: "github-actions[bot]",
              per_page: 100,
            });
            const stale = issues.filter((i) =>
              i.title.startsWith("chore: manual upstream sync required")
            );

            for (const issue of stale) {
              await github.rest.issues.update({
                owner, repo, issue_number: issue.number,
                state: "closed", state_reason: "completed",
              });
              await github.rest.issues.createComment({
                owner, repo, issue_number: issue.number,
                body: `Closed automatically — upstream \`${process.env.TAG}\` merged cleanly in a newer sync run.`,
              });
              core.info(`Closed stale conflict issue #${issue.number}`);
            }
